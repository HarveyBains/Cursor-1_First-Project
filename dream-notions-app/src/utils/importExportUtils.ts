import type { DreamEntry } from '../types/DreamEntry';

// Utility function to generate a client-side ID
const generateId = (): string => `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

export const parseImportMarkdown = (markdownText: string): DreamEntry[] => {
  const dreams: DreamEntry[] = [];
  const lines = markdownText.split('\n');
  
  let currentDreamBlockLines: string[] = [];
  let skipHeaderLines = true; // Flag to skip initial header lines

  const processAndPushDream = (blockLines: string[]) => {
    console.log('Processing dream block:', blockLines);
    if (blockLines.length === 0) return;

    // Find the first line that looks like a dream entry
    let dreamStartIndex = 0;
    for (let i = 0; i < blockLines.length; i++) {
      const line = blockLines[i].trim();
      if (line.match(/^\d{2}\/\d{2}\/\d{2}\s*-\s*/)) {
        dreamStartIndex = i;
        break;
      }
    }

    if (dreamStartIndex >= blockLines.length) return; // No valid dream line found

    const firstLine = blockLines[dreamStartIndex].trim();
    console.log('  Dream entry line:', firstLine);
    
    // Match format: DD/MM/YY - Dream Title, Tags:Tag1,Tag2,Tag3
    // Also handle format without tags: DD/MM/YY - Dream Title
    const dreamFormatMatch = firstLine.match(/^(\d{2}\/\d{2}\/\d{2})\s*-\s*(.*?)(?:,\s*Tags:(.*))?$/);

    if (dreamFormatMatch) {
      const dateString = dreamFormatMatch[1];
      const day = parseInt(dateString.substring(0, 2), 10);
      const month = parseInt(dateString.substring(3, 5), 10) - 1; // Month is 0-indexed
      let year = parseInt(dateString.substring(6, 8), 10);

      // Handle two-digit years (assume 2000s for years 00-69, 1900s for 70-99)
      year = year < 70 ? 2000 + year : 1900 + year;

      console.log(`  Parsed Date Components: Day=${day}, Month=${month + 1}, Year=${year}`);

      const date = new Date(year, month, day);
      const timestamp = !isNaN(date.getTime()) ? date.getTime() : Date.now();
      console.log('  Resulting Timestamp:', timestamp);

      const name = dreamFormatMatch[2].trim();
      const tagsString = dreamFormatMatch[3] ? dreamFormatMatch[3].trim() : '';
      
      // Parse tags - ONLY split on commas, preserve / for hierarchical tags
      let tags: string[] = [];
      if (tagsString) {
        const originalTags = tagsString.split(',').map(t => t.trim());
        console.log(`Parsing tags from: "${tagsString}"`);
        console.log('Original tags:', originalTags);
        
        tags = originalTags.map(tag => {
          const originalTag = tag;
          
          // Normalize tag formatting to prevent duplicates:
          // 1. Remove any existing # prefix first
          if (tag.startsWith('#')) {
            tag = tag.substring(1);
          }
          
          // 2. Add # prefix ONLY to standalone tags (no /)
          // Hierarchical tags (containing /) should never have # prefix
          if (!tag.includes('/')) {
            tag = `#${tag}`;
          }
          
          if (originalTag !== tag) {
            console.log(`  Normalized: "${originalTag}" → "${tag}"`);
          }
          
          return tag;
        }).filter(tag => tag !== '' && tag !== '#' && tag !== '★' && tag !== 'star' && tag !== 'favorites');
        
        console.log('Final normalized tags:', tags);
      }
      
      // Get description from remaining lines
      const description = blockLines.slice(dreamStartIndex + 1)
        .filter(line => line.trim() !== '') // Remove empty lines
        .join('\n').trim();

      dreams.push({
        id: generateId(),
        name,
        timestamp,
        description: description || undefined,
        isFavorite: false,
        tags: tags.length > 0 ? tags : ['#default'], // Ensure at least #default tag
        icon: 'neutral',
        displayOrder: dreams.length * 1000
      } as DreamEntry);
      console.log('  Dream pushed:', dreams[dreams.length - 1]);
    } else {
      console.log('  No valid dream format match for line:', firstLine);
    }
  };

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Skip empty lines
    if (line === '') {
      continue;
    }

    // Skip header/title lines at the beginning
    if (skipHeaderLines && (
      line.startsWith('#') || 
      line.startsWith('*Generated by') ||
      line.toLowerCase().includes('journal') ||
      line.toLowerCase().includes('export')
    )) {
      continue;
    }

    // Once we encounter a non-header line, stop skipping
    if (skipHeaderLines && !line.startsWith('#') && !line.startsWith('*')) {
      skipHeaderLines = false;
    }

    // Check if this line starts a new dream entry
    if (line.match(/^\d{2}\/\d{2}\/\d{2}\s*-\s*/)) {
      // Process any accumulated dream block first
      if (currentDreamBlockLines.length > 0) {
        processAndPushDream(currentDreamBlockLines);
        currentDreamBlockLines = [];
      }
      // Start new dream block with this line
      currentDreamBlockLines.push(line);
      continue;
    }

    // Check for separator (handle both --- and variations)
    if (line === '---' || line === '--' || line.match(/^-{2,}$/)) {
      // End of a dream block, process it
      if (currentDreamBlockLines.length > 0) {
        processAndPushDream(currentDreamBlockLines);
        currentDreamBlockLines = [];
      }
      continue;
    }

    // Add line to current dream block (if we have started one)
    if (currentDreamBlockLines.length > 0 || !skipHeaderLines) {
      currentDreamBlockLines.push(line);
    }
  }

  // Process any remaining dream block after the loop
  if (currentDreamBlockLines.length > 0) {
    processAndPushDream(currentDreamBlockLines);
  }
  
  return dreams;
};

export const exportDreams = async (dreams: DreamEntry[]): Promise<void> => {
  const header = '# Dreams Journal Export\n';
  const footer = `\n*Generated by Dream-Notions on ${new Date().toLocaleDateString()}*`;

  const dreamEntries = dreams.map(dream => {
    const date = new Date(dream.timestamp);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const yearShort = String(date.getFullYear()).slice(-2); // Get last two digits of year

    const formattedDateDDMMYY = `${day}/${month}/${yearShort}`;
    const tags = dream.tags && dream.tags.length > 0 ? dream.tags.join(',') : '#default'; // Ensure #default on export

    // Format: DD/MM/YY - Dream Title, Tags:Tag1,Tag2,Tag3\nDescription\n---
    return `${formattedDateDDMMYY} - ${dream.name}, Tags:${tags}\n${dream.description || ''}\n---`;
  }).join('\n');

  const markdownContent = `${header}${dreamEntries}${footer}`;

  try {
    await navigator.clipboard.writeText(markdownContent);
    alert('Dream data copied to clipboard!');
  } catch (err) {
    console.error('Failed to copy dream data to clipboard:', err);
    alert('Failed to copy dream data to clipboard. Please try again.');
  }
};