import type { DreamEntry } from '../types/DreamEntry';

// Utility function to generate a client-side ID
const generateId = (): string => `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

export const parseImportMarkdown = (markdownText: string): DreamEntry[] => {
  const dreams: DreamEntry[] = [];
  const lines = markdownText.split('\n');
  
  let currentDream: Partial<DreamEntry> | null = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip header, empty lines, separators, and footer
    if (!line || 
        line.startsWith('# Dreams Journal Export') || 
        line === '---' || 
        line.startsWith('*Generated by')) {
      
      // Save current dream when hitting separator or end
      if ((line === '---' || line.startsWith('*Generated by')) && 
          currentDream && currentDream.name && currentDream.description) {
        dreams.push({
          id: generateId(),
          name: currentDream.name,
          timestamp: currentDream.timestamp || Date.now(),
          description: currentDream.description.trim(),
          isFavorite: currentDream.isFavorite || false,
          tags: currentDream.tags || ['#default'],
          icon: 'neutral', // Default icon
          displayOrder: dreams.length * 1000 // Simple initial ordering
        } as DreamEntry);
        currentDream = null;
      }
      continue;
    }
    
    // Parse dream header format
    // Example: 07/07 - Dream: Dad Coming Back July2025, Date: 07072025 - 04:34, Tags: #default, Dreams/People/Dad
    const headerMatch = line.match(/^(.*?)\,\s*Date:\s*(\d{8})\s*-\s*(\d{2}):(\d{2})\,\s*Tags:\s*(.*)$/);
    
    if (headerMatch) {
      // Save previous dream if exists
      if (currentDream && currentDream.name && currentDream.description) {
        dreams.push({
          id: generateId(),
          name: currentDream.name,
          timestamp: currentDream.timestamp || Date.now(),
          description: currentDream.description.trim(),
          isFavorite: currentDream.isFavorite || false,
          tags: currentDream.tags || ['#default'],
          icon: 'neutral',
          displayOrder: dreams.length * 1000
        } as DreamEntry);
      }
      
      // Parse new dream entry
      const dreamName = headerMatch[1].trim();
      const dateStr = headerMatch[2]; // DDMMYYYY
      const hours = parseInt(headerMatch[3]);
      const minutes = parseInt(headerMatch[4]);
      const tagsPart = headerMatch[5];
      
      // Extract timestamp
      let timestamp = Date.now();
      const day = parseInt(dateStr.substring(0, 2));
      const month = parseInt(dateStr.substring(2, 4)) - 1; // JS months are 0-indexed
      const year = parseInt(dateStr.substring(4, 8));
      
      // Handle two-digit years: YY >= 70 -> 19YY, YY < 70 -> 20YY
      let fullYear = year;
      if (year < 100) { // Check if it's a two-digit year
        fullYear = year >= 70 ? 1900 + year : 2000 + year;
      }
      
      const date = new Date(fullYear, month, day, hours, minutes);
      if (!isNaN(date.getTime())) {
        timestamp = date.getTime();
      }
      
      // Extract tags and favorite status
      let tags = ['#default'];
      let isFavorite = false;
      
      if (tagsPart.includes('⭐')) {
        isFavorite = true;
      }
      
      const tagString = tagsPart.replace('⭐', '').trim();
      if (tagString) {
        tags = tagString.split(',').map(tag => tag.trim()).filter(tag => tag);
      }
      
      currentDream = {
        name: dreamName,
        timestamp,
        tags,
        isFavorite,
        description: ''
      };
    } else if (currentDream) {
      // Accumulate dream content
      if (currentDream.description) {
        currentDream.description += '\n' + line; // Preserve newlines in description
      } else {
        currentDream.description = line;
      }
    }
  }
  
  // Save final dream
  if (currentDream && currentDream.name && currentDream.description) {
    dreams.push({
      id: generateId(),
      name: currentDream.name,
      timestamp: currentDream.timestamp || Date.now(),
      description: currentDream.description.trim(),
      isFavorite: currentDream.isFavorite || false,
      tags: currentDream.tags || ['#default'],
      icon: 'neutral',
      displayOrder: dreams.length * 1000
    } as DreamEntry);
  }
  
  return dreams;
};

export const exportDreams = async (dreams: DreamEntry[]): Promise<void> => {
  const header = '# Dreams Journal Export\n\n';
  const footer = `\n*Generated by Dream-Notions on ${new Date().toLocaleDateString()}*`;

  const dreamEntries = dreams.map(dream => {
    const date = new Date(dream.timestamp);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');

    const tags = dream.tags && dream.tags.length > 0 ? dream.tags.join(', ') : '#default';
    const favoriteStar = dream.isFavorite ? '⭐' : '';

    return `07/07 - Dream: ${dream.name}, Date: ${day}${month}${year} - ${hours}:${minutes}, Tags: ${favoriteStar}${tags}\n${dream.description}\n---`;
  }).join('\n');

  const markdownContent = `${header}${dreamEntries}${footer}`;

  try {
    await navigator.clipboard.writeText(markdownContent);
    alert('Dream data copied to clipboard!');
  } catch (err) {
    console.error('Failed to copy dream data to clipboard:', err);
    alert('Failed to copy dream data to clipboard. Please try again.');
  }
};