import type { DreamEntry } from '../types/DreamEntry';

// Utility function to generate a client-side ID
const generateId = (): string => `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

export const parseImportMarkdown = (markdownText: string): DreamEntry[] => {
  const dreams: DreamEntry[] = [];
  const lines = markdownText.split('\n');
  
  let currentDreamBlockLines: string[] = [];

  const processAndPushDream = (blockLines: string[]) => {
    console.log('Processing dream block:', blockLines);
    if (blockLines.length === 0) return;

    const firstLine = blockLines[0].trim();
    console.log('  First line of block:', firstLine);
    // New format: DD/MM/YY - Dream Title, Tags:Tag1,Tag2,Tag3
    const newFormatMatch = firstLine.match(/^(\d{2}\/\d{2}\/\d{2})\s*-\s*(.*?)(?:,\s*Tags:(.*))?$/);

    if (newFormatMatch) {
      const dateString = newFormatMatch[1];
      const day = parseInt(dateString.substring(0, 2), 10);
      const month = parseInt(dateString.substring(3, 5), 10) - 1; // Month is 0-indexed
      let year = parseInt(dateString.substring(6, 8), 10);

      // Handle two-digit years
      year = year < 70 ? 2000 + year : 1900 + year;

      console.log(`  Parsed Date Components: Day=${day}, Month=${month + 1}, Year=${year}`);

      const date = new Date(year, month, day);
      const timestamp = !isNaN(date.getTime()) ? date.getTime() : Date.now();
      console.log('  Resulting Timestamp:', timestamp);

      const name = newFormatMatch[2].trim();
      const tagsString = newFormatMatch[3] ? newFormatMatch[3].trim() : '';
      // After parsing tags for each dream, filter out '★', 'star', and 'favorites'
      const tags = tagsString.split(',').map(tag => tag.trim()).filter(tag => tag !== '' && tag !== '★' && tag !== 'star' && tag !== 'favorites');
      const description = blockLines.slice(1).join('\n').trim();

      dreams.push({
        id: generateId(),
        name,
        timestamp,
        description: description || undefined,
        isFavorite: false, // Default to false for new format
        tags: tags.length > 0 ? tags : ['#default'], // Ensure at least #default tag
        icon: 'neutral', // Default icon
        displayOrder: dreams.length * 1000
      } as DreamEntry);
      console.log('  Dream pushed:', dreams[dreams.length - 1]);
    } else {
      console.log('  No new format match for first line of block:', firstLine);
    }
  };

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // Skip global header/footer lines
    if (line.startsWith('# Dreams Journal Export') || line.startsWith('*Generated by')) {
      continue;
    }

    if (line === '---') {
      // End of a dream block, process it
      if (currentDreamBlockLines.length > 0) {
        processAndPushDream(currentDreamBlockLines);
        currentDreamBlockLines = []; // Reset for next dream
      }
      continue;
    }

    // Add line to current dream block
    currentDreamBlockLines.push(line);
  }

  // Process any remaining dream block after the loop (for the last dream if no trailing ---)
  if (currentDreamBlockLines.length > 0) {
    processAndPushDream(currentDreamBlockLines);
  }
  
  return dreams;
};

export const exportDreams = async (dreams: DreamEntry[]): Promise<void> => {
  const header = '# Dreams Journal Export\n';
  const footer = `\n*Generated by Dream-Notions on ${new Date().toLocaleDateString()}*`;

  const dreamEntries = dreams.map(dream => {
    const date = new Date(dream.timestamp);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const yearShort = String(date.getFullYear()).slice(-2); // Get last two digits of year

    const formattedDateDDMMYY = `${day}/${month}/${yearShort}`;
    const tags = dream.tags && dream.tags.length > 0 ? dream.tags.join(',') : '#default'; // Ensure #default on export

    // Format: DD/MM/YY - Dream Title, Tags:Tag1,Tag2,Tag3\nDescription\n---
    return `${formattedDateDDMMYY} - ${dream.name}, Tags:${tags}\n${dream.description || ''}\n---`;
  }).join('\n');

  const markdownContent = `${header}${dreamEntries}${footer}`;

  try {
    await navigator.clipboard.writeText(markdownContent);
    alert('Dream data copied to clipboard!');
  } catch (err) {
    console.error('Failed to copy dream data to clipboard:', err);
    alert('Failed to copy dream data to clipboard. Please try again.');
  }
};