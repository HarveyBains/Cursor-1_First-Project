import type { DreamEntry } from '../types/DreamEntry';

// Utility function to generate a client-side ID
const generateId = (): string => `${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

export const parseImportMarkdown = (markdownText: string): DreamEntry[] => {
  const dreams: DreamEntry[] = [];
  const lines = markdownText.split('\n');
  
  let currentDream: Partial<DreamEntry> | null = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip header, empty lines, separators, and footer
    if (!line || 
        line.startsWith('# Dreams Journal Export') || 
        line === '---' || 
        line.startsWith('*Generated by')) {
      
      // Save current dream when hitting separator or end
      if ((line === '---' || line.startsWith('*Generated by')) && 
          currentDream && currentDream.name && currentDream.description) {
        dreams.push({
          id: generateId(),
          name: currentDream.name,
          timestamp: currentDream.timestamp || Date.now(),
          description: currentDream.description.trim(),
          isFavorite: currentDream.isFavorite || false,
          tags: currentDream.tags || ['#default'],
          icon: 'neutral', // Default icon
          displayOrder: dreams.length * 1000 // Simple initial ordering
        } as DreamEntry);
        currentDream = null;
      }
      continue;
    }
    
    // Parse dream header format
    // Example: 07/07 - Dream: Dad Coming Back July2025, Date: 07072025 - 04:34, Tags: #default, Dreams/People/Dad
    const headerMatch = line.match(/^(.*?),\s*Date:\s*(\d{8})\s*-\s*(\d{2}):(\d{2}),\s*Tags:\s*(.*)$/);
    
    if (headerMatch) {
      // Save previous dream if exists
      if (currentDream && currentDream.name && currentDream.description) {
        dreams.push({
          id: generateId(),
          name: currentDream.name,
          timestamp: currentDream.timestamp || Date.now(),
          description: currentDream.description.trim(),
          isFavorite: currentDream.isFavorite || false,
          tags: currentDream.tags || ['#default'],
          icon: 'neutral',
          displayOrder: dreams.length * 1000
        } as DreamEntry);
      }
      
      // Parse new dream entry
      const dreamName = headerMatch[1].trim();
      const dateStr = headerMatch[2]; // DDMMYYYY
      const hours = parseInt(headerMatch[3]);
      const minutes = parseInt(headerMatch[4]);
      const tagsPart = headerMatch[5];
      
      // Extract timestamp
      let timestamp = Date.now();
      const day = parseInt(dateStr.substring(0, 2));
      const month = parseInt(dateStr.substring(2, 4)) - 1; // JS months are 0-indexed
      const year = parseInt(dateStr.substring(4, 8));
      
      const date = new Date(year, month, day, hours, minutes);
      if (!isNaN(date.getTime())) {
        timestamp = date.getTime();
      }
      
      // Extract tags and favorite status
      let tags = ['#default'];
      let isFavorite = false;
      
      if (tagsPart.includes('⭐')) {
        isFavorite = true;
      }
      
      const tagString = tagsPart.replace('⭐', '').trim();
      if (tagString) {
        tags = tagString.split(',').map(tag => tag.trim()).filter(tag => tag);
      }
      
      currentDream = {
        name: dreamName,
        timestamp,
        tags,
        isFavorite,
        description: ''
      };
    } else if (currentDream) {
      // Accumulate dream content
      if (currentDream.description) {
        currentDream.description += '\n' + line; // Preserve newlines in description
      } else {
        currentDream.description = line;
      }
    }
  }
  
  // Save final dream
  if (currentDream && currentDream.name && currentDream.description) {
    dreams.push({
      id: generateId(),
      name: currentDream.name,
      timestamp: currentDream.timestamp || Date.now(),
      description: currentDream.description.trim(),
      isFavorite: currentDream.isFavorite || false,
      tags: currentDream.tags || ['#default'],
      icon: 'neutral',
      displayOrder: dreams.length * 1000
    } as DreamEntry);
  }
  
  return dreams;
};